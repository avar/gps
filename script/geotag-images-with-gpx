#!/usr/bin/env perl
use strict;
use Pod::Usage ();
use Getopt::Long ();
use File::Slurp qw(slurp);
use DateTime::Format::DateParse;
use Image::ExifTool;
use Image::ExifTool::Location;

=head1 NAME

geotag-images-with-gpx - Take arbitary number of gpx files and images and Exif tag the images with GPS points

=head1 SYNOPSIS

    geotag-images-with-gpx [--range=RANGE] [--offset=OFFSET] [IMAGE AND GPX FILES..]

    # Tag an image taken at 13:07:08 (according to the GPS) with a
    # timestamp of 13:07:03 in its Exif data
    geotag-images-with-gpx --offset=+5 track.gpx image.jpg

    # Tag a whole directory of JPEG and RAW images
    geotag-images-with-gpx --offset=+5 track.gpx *.cr2 *.jpg

=head1 DESCRIPTION

Takes an abitary number of GPX and image files on the command line and
tags the image files with the GPX point found to be recorded closest
in time to the time the image was taken.

This program uses L<Image::ExifTool> and can tag any image format
supported by that library, including F<CR2> and F<JPG> images.

=head1 OPTIONS

=over

=item -h, --help

Print a usage message listing all availible options

=item --range

For each image we process on the command line we'll search a given
number of seconds back and forward in time and see if we can find a
GPX point in that time period which will be used to tag the image.

The closest point in time will then be used.

60 by default.

=item --offset

How much needs to be added to your Camera's timestamp so that it syncs
up with the GPS', obviously a negative value can be specified.

    $ exiftool *8289*jpg | grep ^Create
    Create Date: 2008:07:30 13:07:03

The image was actually taken at 13:07:08, so --offset=+5 needs to be
specified.

0 by default.

=item --camera-time, --gps-time

If you're too lazy to calculate the C<--offset> parameter yourself use these two, e.g.:

    --camera-time=13:07:03 --gps-time=13:07:08

instead of:

    --offset=+5

The offset will be calculated with L<DateTime::Format::DateParse>.

=back

=head1 AUTHOR

E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avar@f-prot.com>

=cut

Getopt::Long::Parser->new(
    config => [ qw< bundling no_ignore_case no_require_order pass_through > ],
)->getoptions(
    'h|help' => \my $help,
    'range=i' => \(my $range = 60),
    'offset=s' => \(my $offset = 0),
    'lat=s' => \my $lat,
    'lon=s' => \my $lon,
    'ele=s' => \my $ele,
    'camera-time=s' => \my $camera_time,
    'gps-time=s' => \my $gps_time,
) or help();

help() if $help;

# Manual tagging mode?
my $manual = 0;

my (@gpx, @img);

help() unless @ARGV;

if ($camera_time && !$gps_time or $gps_time && !$camera_time) {
    warn "Both --camera-time and --gps-time have to be specified";
    help();
}

if ($offset && ($camera_time or $gps_time)) {
    warn "--offset and --gps-time --camera-time are mutually exclusive";
    help();
}

if ($lat or $lon or $ele) {
    if (not (defined $lat and defined $lon and defined $ele)) {
        warn "--lat --lon and --ele all have to be specified at once";
        help();
    }

    $manual = 1;
}

if ($camera_time and $gps_time) {
    $offset = calculate_time_offset($camera_time, $gps_time);
}

for (@ARGV) {
    if (/\.gpx$/i) {
        push @gpx, $_ if -f $_;
    } else {
        push @img, $_ if -f $_;
    }
}

my %data;
unless ($manual) {
    print "Building point database from gpx files...";
    %data = get_points_from_gpx(@gpx);
    print "done\n";
}

for my $src (@img) {
    my $exif = Image::ExifTool->new;

    $exif->ExtractInfo($src);
    my $date = $exif->GetValue('CreateDate');

    my $dt = DateTime::Format::DateParse->parse_datetime( $date );
    unless ($dt) {
        warn "Couldn't parse date from '$src', date was '$date'";
        next;
    }
    my $time = $dt->epoch;

    my $start = $time + $offset - $range;
    my $stop  = $time + $offset + $range;

    my %diff;
    for my $second ($start .. $stop) {
        if (my $coord = $data{$second}) {
            my $diff = abs $second - $time;

            if ($diff{$diff}) {
                # This means we have a point e.g. -2 and +2, do
                # something smart to pick either one rather than just
                # the positive one.
            }
            $diff{$diff} = $coord;
        }
    }

    my $best_key = (sort { $a <=> $b } keys %diff)[0];
    my $best;

    unless ($manual) {
        $best = $diff{$best_key};
    } else {
        $best->{lat} = $lat;
        $best->{lon} = $lon;
        $best->{ele} = $ele;
    }

    unless ($best) {
        warn "Could not find a gps point within $range seconds for $src from the given gpx data";
        next;
    }

    # Set location
    $exif->SetLocation($best->{lat}, $best->{lon});
    # Set elevation
    $exif->SetElevation($best->{ele});

    my $dst = $src; $dst =~ s/\./-geo./;
    print "Saving $src with geodata `$best->{lat}',`$best->{lon}':`$best->{ele}' as `$dst'";
    unless ($manual) {
        print ", point offset by $best_key seconds with a constant offset of $offset";
    }
    print "\n";
    unless ($exif->WriteInfo($src, $dst)) {
        warn "Failed to write a version of `$src` with exif data as `$dst': $!";
        sleep 2;
    }

    system "mv -v $dst $src";
}

sub get_points_from_gpx
{
    my @gpx = @_;
    my %data;

    for my $gpx (@gpx) {
        my $cont = slurp($gpx);

        # FIXME: Make a real XML parser
        my $rx = qr[
                       <trkpt\ lat="(.*?)"\ lon="(.*?)"> \s*
                       <ele>(.*?)</ele> \s*
                       <time>(.*?)</time> \s*
                       </trkpt>
               ]xs;

        while ($cont =~ /$rx/g) {
            my $lat  = $1;
            my $lon  = $2;
            my $ele  = $3;
            my $date = $4;

            my $dt = DateTime::Format::DateParse->parse_datetime( $date );
            my $time = $dt->epoch;

            $data{$time} = {
                lat => $lat,
                lon => $lon,
                ele => $ele,
                date => $date,
            };
        }
    }

    return %data;
}

sub calculate_time_offset
{
    my ($camera_time, $gps_time) = @_;

    my $cdt = DateTime::Format::DateParse->parse_datetime( $camera_time );
    my $gdt = DateTime::Format::DateParse->parse_datetime( $gps_time );

    return $gdt->epoch - $cdt->epoch;
}

sub help
{
    my %arg = @_;

    Pod::Usage::pod2usage(
        -verbose => $arg{ verbose },
        -exitval => $arg{ exitval } || 0,
    );
}
