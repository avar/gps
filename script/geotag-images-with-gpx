#!/usr/bin/env perl
use strict;
use Pod::Usage ();
use Getopt::Long ();
use File::Slurp qw(slurp);
use DateTime::Format::DateParse;
use Image::ExifTool;
use Image::ExifTool::Location;

=head1 NAME

geotag-images-with-gpx - Take arbitary number of gpx files and images and Exif tag the images with GPS points

=head1 SYNOPSIS

    geotag-images-with-gpx [--range=RANGE] [--offset=OFFSET] [IMAGE AND GPX FILES..]

=head1 DESCRIPTION

Takes an abitary number of GPX and image files on the command line and
tags the image files with the GPX point found to be recorded closest
in time to the time the image was taken.

This program uses L<Image::ExifTool> and can tag any image format
supported by that library, including F<CR2> and F<JPG> images.

=head1 OPTIONS

=over

=item -h, --help

Print a usage message listing all availible options

=item --range

For each image we process on the command line we'll search a given
number of seconds back and forward in time and see if we can find a
GPX point in that time period which will be used to tag the image.

The closest point in time will then be used.

60 by default.

=item --offset

How much needs to be added to your Camera's timestamp so that it syncs
up with the GPS', obviously a negavite value can be specified.

    $ exiftool *8289*jpg | grep ^Create
    Create Date: 2008:07:30 13:07:03

The image was actually taken at 13:07:08, so --offset=+5 needs to be
specified.

0 by default.

=back

=head1 AUTHOR

E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avar@f-prot.com>

=cut

Getopt::Long::Parser->new(
    config => [ qw< bundling no_ignore_case no_require_order pass_through > ],
)->getoptions(
    'h|help' => \my $help,
    'range=i' => \(my $range = 60),
    'offset=s' => \(my $offset = 0),
) or help();

my (@gpx, @img);

help() unless @ARGV;

for (@ARGV) {
    if (/\.gpx$/i) {
        push @gpx, $_;
    } else {
        push @img, $_;
    }
}

print "Building point database from gpx files...";
my %data = get_points_from_gpx(@gpx);
print "done\n";

for my $src (@img) {
    my $exif = Image::ExifTool->new;

    $exif->ExtractInfo($src);
    my $date = $exif->GetValue('CreateDate');

    my $dt = DateTime::Format::DateParse->parse_datetime( $date );
    my $time = $dt->epoch;

    my $start = $time + $offset - $range;
    my $stop  = $time + $offset + $range;

    my %diff;
    for my $second ($start .. $stop) {
        if (my $coord = $data{$second}) {
            my $diff = abs $second - $time;

            if ($diff{$diff}) {
                # This means we have a point e.g. -2 and +2, do
                # something smart to pick either one rather than just
                # the positive one.
            }
            $diff{$diff} = $coord;
        }
    }

    my $best_key = (sort { $a <=> $b } keys %diff)[0];
    my $best = $diff{$best_key};

    unless ($best) {
        warn "Could not find a gps point within $range seconds for $src from the given gpx data";
        next;
    }

    # Set location
    $exif->SetLocation($best->{lat}, $best->{lon});
    # Set elevation
    $exif->SetElevation($best->{ele});

    my $dst = $src; $dst =~ s/\./-geo./;
    print "Saving $src with geodata as $dst, point offset by $best_key seconds\n";
    unless ($exif->WriteInfo($src, $dst)) {
        die "Failed to write a version of `$src` with exif data as `$dst': $!";
    }

    system "mv -v $dst $src";
}

sub get_points_from_gpx
{
    my @gpx = @_;
    my %data;

    for my $gpx (@gpx) {
        my $cont = slurp($gpx);

        # FIXME: Make a real XML parser
        my $rx = qr[
                       <trkpt\ lat="(.*?)"\ lon="(.*?)"> \s*
                       <ele>(.*?)</ele> \s*
                       <time>(.*?)</time> \s*
                       </trkpt>
               ]xs;

        while ($cont =~ /$rx/g) {
            my $lat  = $1;
            my $lon  = $2;
            my $ele  = $3;
            my $date = $4;

            my $dt = DateTime::Format::DateParse->parse_datetime( $date );
            my $time = $dt->epoch;

            $data{$time} = {
                lat => $lat,
                lon => $lon,
                ele => $ele,
                date => $date,
            };
        }
    }

    return %data;
}

sub help
{
    my %arg = @_;

    Pod::Usage::pod2usage(
        -verbose => $arg{ verbose },
        -exitval => $arg{ exitval } || 0,
    );
}
