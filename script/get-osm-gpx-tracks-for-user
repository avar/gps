#!/usr/bin/env perl
use strict;
use warnings;

use Pod::Usage ();
use Getopt::Long ();

use WWW::Mechanize;
use URI::Escape;

use File::Spec::Functions qw(catfile);
use File::Temp qw(tempfile);
use Cwd qw(abs_path);

=head1 NAME

get-osm-gpx-tracks-for-user - Get all the F<.gpx> tracks a given L<openstreetmap.org> user has uploaded

=head1 SYNOPSIS

    perl get-osm-gpx-tracks-for-user [--debug] "Ævar Arnfjörð Bjarmason"

=head1 OPTIONS

=over

=item --help

Display this help message

=item --debug

Print debugging information with C<warn>.

=item --download

Download GPX traces, don't just display them, requires C<--out-dir>.

=item --out-dir

The output directory (if using C<--download>), this need not be an
absolute path as C<Cwd::abs_path()> will be called on it.

=item --skip-existing, --no-skip-existing

If C<--skip-existing> don't download traces in the C<--out-dir> we've
already downloaded. C<--skip-existing> is the default.

=back

=cut

Getopt::Long::Parser->new(
    config => [ qw< bundling no_ignore_case no_require_order pass_through > ],
)->getoptions(
    'h|help'     => \my $help,
    'debug'      => \my $debug,
    'out-dir=s'  => \my $out_dir,
    'download!'  => \my $download,
    'skip-existing!' => \(my $skip_existing = 1),
) or help();

help() if $help;
if ($download && !$out_dir or !$download && $out_dir) {
    warn "--out-dir must be specified with --download";
    help();
}

#
# main program
#

my $mech = WWW::Mechanize->new();

my $user = $ARGV[0];
my $user_esc =  uri_escape($user);
my $user_traces = "http://openstreetmap.org/user/$user_esc/traces";

warn "User traces: $user_traces" if $debug;

$mech->get( $user_traces );

my $num_pages = num_pages_from_links($mech);

my @links;
for my $page (1 .. $num_pages) {
    warn "page $page for user $user" if $debug;
    $mech->get($user_traces . "/page/$page");

    push @links, gpx_links_on_page($mech);
}

if ($download) {
    my $o_dir = abs_path($out_dir);
    die "Couldn't resolve abs_path($out_dir)" unless $o_dir;

    unless (-d $o_dir) {
        mkdir $o_dir or die "Couldn't mkdir($o_dir): $!";
    }

    for my $link (@links) {
        my ($trace, $trace_url, $text, $url) = @$link{qw(trace trace_url text url)};

        my $out_file = catfile($o_dir, $text);

        if (-f $out_file && $skip_existing) {
            warn "Skipping existing trace `$trace' with the name `$text'";
        } else {
            warn "Getting trace `$trace' with the name `$text'" if $debug;
            download_track_url_to_file_and_ungzip($trace_url, $out_file);
        }
    }
} else {
    for my $link (@links) {
        printf "%s\t%s\t%s\n", @$link{qw(trace trace_url text)};
    }
}

sub download_track_url_to_file_and_ungzip
{
    my ($url, $file) = @_;
    my ($t_fh, $t_filename) = tempfile();

    system qq[wget -q $url -O $t_filename];
    my $what = qx[file $t_filename];

    if ($what =~ /gzip compressed data/) {
        system qq[cat $t_filename | gzip -d > $file];
        system qq[rm $t_filename];
        undef $t_fh;
        undef $t_filename;
    } else {
        system qq[mv $t_filename $file];
    }
}

sub trace_name_from_content {
    my $trace = shift;
    my $content = shift;

    #<a href="/user/%C3%86var%20Arnfj%C3%B6r%C3%B0%20Bjarmason/traces/335388">2009_03_15_Driving_on_Highway_1_from_Akureyri_to_Reykjavik.gpx</a>
    my ($name) = $content =~ m[<a href="/user/[^/]+/traces/$trace">(.+?\.gpx)</a>];

    return $name;
}

sub gpx_links_on_page
{
    my $mech = shift;
    my @links = $mech->links;
    my @gpx_link;

    my %traces;

    for my $link (@links) {

        if ($link->url_abs =~ m[/traces/([0-9]+)$]) {
            my $trace = $1;
            next if $traces{$trace};
            $traces{$trace} = 1;
            push @gpx_link => {
                url  => $link->url_abs,
                text => trace_name_from_content($trace, $mech->content),
                trace => $trace,
                trace_url => "http://openstreetmap.org/trace/$1/data",
            };
        }

    }

    return @gpx_link;
}

sub num_pages_from_links
{
    my $mech = shift;
    my @links = $mech->links;
    my $pages = 1;

    for my $link (@links) {
        next unless ($link->url_abs . "") =~ m[/page/([0-9]+)$];

        $pages = $1 if $pages < $1;
    }

    return $pages;
}

sub help
{
    my %arg = @_;

    Pod::Usage::pod2usage(
        -verbose => $arg{ verbose },
        -exitval => $arg{ exitval } || 0,
    );
}
